#!/usr/bin/env python3
"""
CloudHawk Vulnerability Scanner

This module scans AWS resources for known vulnerabilities and security weaknesses
based on CVE databases, security advisories, and best practices.
"""

import os
import json
import logging
import requests
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from collections import defaultdict
import re

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Multi-cloud vulnerability scanner for AWS, Azure, and GCP"""
    
    def __init__(self, config: Dict = None):
        """Initialize the vulnerability scanner"""
        self.config = config or {}
        self.cve_database = self._load_cve_database()
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.severity_scores = {
            'CRITICAL': 10,
            'HIGH': 8,
            'MEDIUM': 5,
            'LOW': 2,
            'INFO': 1
        }
    
    def _load_cve_database(self) -> Dict:
        """Load CVE database (simplified version)"""
        # In a real implementation, this would load from a comprehensive CVE database
        return {
            # AWS-specific CVEs
            'CVE-2021-44228': {  # Log4Shell
                'description': 'Apache Log4j2 Remote Code Execution',
                'severity': 'CRITICAL',
                'cvss_score': 10.0,
                'affected_services': ['AWS_EC2', 'AWS_Lambda', 'AWS_ECS'],
                'affected_providers': ['AWS'],
                'remediation': 'Update Log4j to version 2.17.0 or later'
            },
            'CVE-2021-45046': {  # Log4Shell follow-up
                'description': 'Apache Log4j2 Denial of Service',
                'severity': 'HIGH',
                'cvss_score': 9.0,
                'affected_services': ['AWS_EC2', 'AWS_Lambda', 'AWS_ECS'],
                'affected_providers': ['AWS'],
                'remediation': 'Update Log4j to version 2.17.0 or later'
            },
            # Azure-specific CVEs
            'CVE-2021-34527': {  # PrintNightmare
                'description': 'Windows Print Spooler Remote Code Execution',
                'severity': 'CRITICAL',
                'cvss_score': 9.8,
                'affected_services': ['AZURE_VM', 'AZURE_AKS'],
                'affected_providers': ['Azure'],
                'remediation': 'Apply Windows security updates and disable Print Spooler service'
            },
            'CVE-2021-26855': {  # Hafnium Exchange
                'description': 'Microsoft Exchange Server Remote Code Execution',
                'severity': 'CRITICAL',
                'cvss_score': 9.1,
                'affected_services': ['AZURE_VM', 'AZURE_APP_SERVICE'],
                'affected_providers': ['Azure'],
                'remediation': 'Apply Microsoft Exchange security updates immediately'
            },
            # GCP-specific CVEs
            'CVE-2021-22205': {  # GitLab RCE
                'description': 'GitLab Unauthenticated Remote Code Execution',
                'severity': 'CRITICAL',
                'cvss_score': 9.9,
                'affected_services': ['GCP_COMPUTE', 'GCP_GKE'],
                'affected_providers': ['GCP'],
                'remediation': 'Update GitLab to version 13.10.3 or later'
            },
            'CVE-2021-4034': {  # PwnKit
                'description': 'Polkit Privilege Escalation',
                'severity': 'HIGH',
                'cvss_score': 7.8,
                'affected_services': ['GCP_COMPUTE', 'GCP_GKE'],
                'affected_providers': ['GCP'],
                'remediation': 'Update system packages and apply security patches'
            },
            # Multi-cloud CVEs
            'CVE-2021-44228-MULTI': {  # Log4Shell multi-cloud
                'description': 'Apache Log4j2 Remote Code Execution (Multi-Cloud)',
                'severity': 'CRITICAL',
                'cvss_score': 10.0,
                'affected_services': ['AWS_EC2', 'AZURE_VM', 'GCP_COMPUTE'],
                'affected_providers': ['AWS', 'Azure', 'GCP'],
                'remediation': 'Update Log4j to version 2.17.0 or later across all cloud providers'
            },
            'CVE-2021-45046-MULTI': {  # Log4Shell follow-up multi-cloud
                'description': 'Apache Log4j2 Denial of Service (Multi-Cloud)',
                'severity': 'HIGH',
                'cvss_score': 8.6,
                'affected_services': ['AWS_EC2', 'AZURE_VM', 'GCP_COMPUTE'],
                'affected_providers': ['AWS', 'Azure', 'GCP'],
                'remediation': 'Update Log4j to version 2.17.1 or later across all cloud providers'
            },
            'CVE-2022-22965': {  # Spring4Shell
                'description': 'Spring Framework Remote Code Execution',
                'severity': 'CRITICAL',
                'cvss_score': 9.8,
                'affected_services': ['EC2', 'Lambda', 'ECS'],
                'remediation': 'Update Spring Framework to version 5.3.18 or later'
            }
        }
    
    def _load_vulnerability_patterns(self) -> Dict:
        """Load vulnerability detection patterns"""
        return {
            'weak_crypto': {
                'patterns': [
                    r'MD5',
                    r'SHA1',
                    r'DES',
                    r'RC4',
                    r'SSLv2',
                    r'SSLv3',
                    r'TLS1\.0'
                ],
                'severity': 'MEDIUM',
                'description': 'Weak cryptographic algorithms detected',
                'remediation': 'Use strong cryptographic algorithms (AES-256, SHA-256, TLS 1.2+)'
            },
            'default_credentials': {
                'patterns': [
                    r'admin:admin',
                    r'root:root',
                    r'password:password',
                    r'user:user',
                    r'guest:guest'
                ],
                'severity': 'CRITICAL',
                'description': 'Default credentials detected',
                'remediation': 'Change default credentials immediately'
            },
            'exposed_secrets': {
                'patterns': [
                    # AWS secrets
                    r'AKIA[0-9A-Z]{16}',  # AWS Access Key ID
                    r'[0-9a-zA-Z/+]{40}',  # AWS Secret Access Key
                    # Azure secrets
                    r'[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}',  # Azure Client ID
                    r'[A-Za-z0-9+/]{40}={0,2}',  # Azure Client Secret
                    # GCP secrets
                    r'[0-9a-f]{40}',  # GCP Service Account Key
                    r'AIza[0-9A-Za-z_-]{35}',  # Google API Key
                    # Generic secrets
                    r'sk_live_[0-9a-zA-Z]{24}',  # Stripe secret key
                    r'xoxb-[0-9]{11}-[0-9]{11}-[0-9a-zA-Z]{24}',  # Slack bot token
                    r'ghp_[0-9a-zA-Z]{36}',  # GitHub personal access token
                    r'-----BEGIN PRIVATE KEY-----',
                    r'-----BEGIN RSA PRIVATE KEY-----'
                ],
                'severity': 'CRITICAL',
                'description': 'Exposed secrets or private keys detected',
                'remediation': 'Rotate exposed credentials and remove from code'
            },
            'sql_injection': {
                'patterns': [
                    r'SELECT.*FROM.*WHERE.*=.*\$\{',
                    r'INSERT.*INTO.*VALUES.*\$\{',
                    r'UPDATE.*SET.*=.*\$\{',
                    r'DELETE.*FROM.*WHERE.*\$\{'
                ],
                'severity': 'HIGH',
                'description': 'Potential SQL injection vulnerability',
                'remediation': 'Use parameterized queries and input validation'
            },
            'xss_vulnerability': {
                'patterns': [
                    r'<script[^>]*>.*</script>',
                    r'javascript:',
                    r'onload\s*=',
                    r'onerror\s*=',
                    r'onclick\s*='
                ],
                'severity': 'MEDIUM',
                'description': 'Potential XSS vulnerability',
                'remediation': 'Implement proper input sanitization and output encoding'
            },
            'path_traversal': {
                'patterns': [
                    r'\.\./',
                    r'\.\.\\',
                    r'%2e%2e%2f',
                    r'%2e%2e%5c',
                    r'\.\.%2f',
                    r'\.\.%5c'
                ],
                'severity': 'HIGH',
                'description': 'Potential path traversal vulnerability',
                'remediation': 'Validate and sanitize file paths'
            },
            'command_injection': {
                'patterns': [
                    r';\s*(rm|del|format|shutdown)',
                    r'\|\s*(rm|del|format|shutdown)',
                    r'&&\s*(rm|del|format|shutdown)',
                    r'\$\{.*\$\(',
                    r'`.*`'
                ],
                'severity': 'CRITICAL',
                'description': 'Potential command injection vulnerability',
                'remediation': 'Avoid executing user input as system commands'
            }
        }
    
    def scan_vulnerabilities(self, events: List[Dict], resource_configs: Dict = None) -> Dict:
        """Scan for vulnerabilities in multi-cloud resources (AWS, Azure, GCP)"""
        logger.info(f"Starting multi-cloud vulnerability scan on {len(events)} events")
        
        scan_results = {
            'timestamp': datetime.utcnow().isoformat(),
            'total_vulnerabilities': 0,
            'critical_vulnerabilities': 0,
            'high_vulnerabilities': 0,
            'medium_vulnerabilities': 0,
            'low_vulnerabilities': 0,
            'info_vulnerabilities': 0,
            'vulnerabilities': [],
            'summary': {},
            'recommendations': []
        }
        
        # Scan for pattern-based vulnerabilities
        pattern_vulns = self._scan_pattern_vulnerabilities(events)
        scan_results['vulnerabilities'].extend(pattern_vulns)
        
        # Scan for CVE-based vulnerabilities
        cve_vulns = self._scan_cve_vulnerabilities(events, resource_configs)
        scan_results['vulnerabilities'].extend(cve_vulns)
        
        # Scan for configuration vulnerabilities
        config_vulns = self._scan_configuration_vulnerabilities(events, resource_configs)
        scan_results['vulnerabilities'].extend(config_vulns)
        
        # Scan for runtime vulnerabilities
        runtime_vulns = self._scan_runtime_vulnerabilities(events)
        scan_results['vulnerabilities'].extend(runtime_vulns)
        
        # Update counts
        for vuln in scan_results['vulnerabilities']:
            scan_results['total_vulnerabilities'] += 1
            severity = vuln.get('severity', 'INFO')
            scan_results[f'{severity.lower()}_vulnerabilities'] += 1
        
        # Generate summary and recommendations
        scan_results['summary'] = self._generate_summary(scan_results)
        scan_results['recommendations'] = self._generate_recommendations(scan_results)
        
        logger.info(f"Vulnerability scan complete. Found {scan_results['total_vulnerabilities']} vulnerabilities")
        return scan_results
    
    def _scan_pattern_vulnerabilities(self, events: List[Dict]) -> List[Dict]:
        """Scan for pattern-based vulnerabilities"""
        vulnerabilities = []
        
        for event in events:
            # Check event description
            description = event.get('description', '')
            raw_event = event.get('raw_event', {})
            
            # Combine all text fields for scanning
            text_to_scan = f"{description} {json.dumps(raw_event)}"
            
            for vuln_type, vuln_config in self.vulnerability_patterns.items():
                for pattern in vuln_config['patterns']:
                    if re.search(pattern, text_to_scan, re.IGNORECASE):
                        vulnerability = {
                            'type': vuln_type,
                            'title': vuln_config['description'],
                            'description': f"Pattern '{pattern}' detected in {event.get('source', 'UNKNOWN')} event",
                            'severity': vuln_config['severity'],
                            'cvss_score': self.severity_scores.get(vuln_config['severity'], 1),
                            'remediation': vuln_config['remediation'],
                            'affected_resource': event.get('resource_id', 'UNKNOWN'),
                            'source': event.get('source', 'UNKNOWN'),
                            'timestamp': datetime.utcnow().isoformat(),
                            'details': {
                                'pattern': pattern,
                                'event_id': event.get('resource_id', ''),
                                'raw_event': raw_event
                            }
                        }
                        vulnerabilities.append(vulnerability)
                        break  # Only report once per vulnerability type per event
        
        return vulnerabilities
    
    def _scan_cve_vulnerabilities(self, events: List[Dict], resource_configs: Dict = None) -> List[Dict]:
        """Scan for CVE-based vulnerabilities"""
        vulnerabilities = []
        
        # Check for known vulnerable software versions
        for event in events:
            description = event.get('description', '').lower()
            raw_event = event.get('raw_event', {})
            
            # Check for Log4j vulnerabilities
            if 'log4j' in description or 'log4j' in str(raw_event).lower():
                if '2.16' in description or '2.15' in description or '2.14' in description:
                    vulnerability = {
                        'type': 'cve_vulnerability',
                        'cve_id': 'CVE-2021-44228',
                        'title': 'Log4Shell Vulnerability (CVE-2021-44228)',
                        'description': 'Apache Log4j2 Remote Code Execution vulnerability detected',
                        'severity': 'CRITICAL',
                        'cvss_score': 10.0,
                        'remediation': 'Update Log4j to version 2.17.0 or later',
                        'affected_resource': event.get('resource_id', 'UNKNOWN'),
                        'source': event.get('source', 'UNKNOWN'),
                        'timestamp': datetime.utcnow().isoformat(),
                        'details': {
                            'cve_details': self.cve_database['CVE-2021-44228'],
                            'event_id': event.get('resource_id', ''),
                            'raw_event': raw_event
                        }
                    }
                    vulnerabilities.append(vulnerability)
            
            # Check for Spring Framework vulnerabilities
            if 'spring' in description or 'spring' in str(raw_event).lower():
                if '5.3.17' in description or '5.2.20' in description:
                    vulnerability = {
                        'type': 'cve_vulnerability',
                        'cve_id': 'CVE-2022-22965',
                        'title': 'Spring4Shell Vulnerability (CVE-2022-22965)',
                        'description': 'Spring Framework Remote Code Execution vulnerability detected',
                        'severity': 'CRITICAL',
                        'cvss_score': 9.8,
                        'remediation': 'Update Spring Framework to version 5.3.18 or later',
                        'affected_resource': event.get('resource_id', 'UNKNOWN'),
                        'source': event.get('source', 'UNKNOWN'),
                        'timestamp': datetime.utcnow().isoformat(),
                        'details': {
                            'cve_details': self.cve_database['CVE-2022-22965'],
                            'event_id': event.get('resource_id', ''),
                            'raw_event': raw_event
                        }
                    }
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _scan_configuration_vulnerabilities(self, events: List[Dict], resource_configs: Dict = None) -> List[Dict]:
        """Scan for configuration-based vulnerabilities"""
        vulnerabilities = []
        
        if not resource_configs:
            return vulnerabilities
        
        # Check S3 bucket configurations
        for bucket_name, config in resource_configs.get('s3_buckets', {}).items():
            # Check for public read access
            if config.get('public_read', False):
                vulnerability = {
                    'type': 'configuration_vulnerability',
                    'title': 'S3 Bucket Public Read Access',
                    'description': f'S3 bucket {bucket_name} allows public read access',
                    'severity': 'HIGH',
                    'cvss_score': 7.5,
                    'remediation': 'Remove public read access and use IAM policies for access control',
                    'affected_resource': bucket_name,
                    'source': 'AWS_S3',
                    'timestamp': datetime.utcnow().isoformat(),
                    'details': {
                        'bucket_name': bucket_name,
                        'configuration': config
                    }
                }
                vulnerabilities.append(vulnerability)
            
            # Check for missing encryption
            if not config.get('encryption_enabled', False):
                vulnerability = {
                    'type': 'configuration_vulnerability',
                    'title': 'S3 Bucket Encryption Disabled',
                    'description': f'S3 bucket {bucket_name} does not have encryption enabled',
                    'severity': 'MEDIUM',
                    'cvss_score': 5.0,
                    'remediation': 'Enable server-side encryption for the S3 bucket',
                    'affected_resource': bucket_name,
                    'source': 'AWS_S3',
                    'timestamp': datetime.utcnow().isoformat(),
                    'details': {
                        'bucket_name': bucket_name,
                        'configuration': config
                    }
                }
                vulnerabilities.append(vulnerability)
        
        # Check EC2 instance configurations
        for instance_id, config in resource_configs.get('ec2_instances', {}).items():
            # Check for public IP
            if config.get('public_ip', False):
                vulnerability = {
                    'type': 'configuration_vulnerability',
                    'title': 'EC2 Instance with Public IP',
                    'description': f'EC2 instance {instance_id} has a public IP address',
                    'severity': 'MEDIUM',
                    'cvss_score': 5.0,
                    'remediation': 'Use private subnets and load balancers instead of direct public IPs',
                    'affected_resource': instance_id,
                    'source': 'AWS_EC2',
                    'timestamp': datetime.utcnow().isoformat(),
                    'details': {
                        'instance_id': instance_id,
                        'configuration': config
                    }
                }
                vulnerabilities.append(vulnerability)
            
            # Check for unencrypted EBS volumes
            for volume in config.get('volumes', []):
                if not volume.get('encrypted', False):
                    vulnerability = {
                        'type': 'configuration_vulnerability',
                        'title': 'Unencrypted EBS Volume',
                        'description': f'EBS volume {volume.get("id", "unknown")} is not encrypted',
                        'severity': 'HIGH',
                        'cvss_score': 7.0,
                        'remediation': 'Enable encryption for EBS volumes',
                        'affected_resource': volume.get('id', 'unknown'),
                        'source': 'AWS_EC2',
                        'timestamp': datetime.utcnow().isoformat(),
                        'details': {
                            'volume_id': volume.get('id', 'unknown'),
                            'instance_id': instance_id,
                            'configuration': volume
                        }
                    }
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _scan_runtime_vulnerabilities(self, events: List[Dict]) -> List[Dict]:
        """Scan for runtime vulnerabilities"""
        vulnerabilities = []
        
        # Check for suspicious runtime behavior
        for event in events:
            description = event.get('description', '').lower()
            raw_event = event.get('raw_event', {})
            
            # Check for privilege escalation attempts
            if 'privilege' in description and 'escalation' in description:
                vulnerability = {
                    'type': 'runtime_vulnerability',
                    'title': 'Privilege Escalation Attempt',
                    'description': 'Potential privilege escalation attempt detected',
                    'severity': 'HIGH',
                    'cvss_score': 8.0,
                    'remediation': 'Review and restrict user permissions',
                    'affected_resource': event.get('resource_id', 'UNKNOWN'),
                    'source': event.get('source', 'UNKNOWN'),
                    'timestamp': datetime.utcnow().isoformat(),
                    'details': {
                        'event_id': event.get('resource_id', ''),
                        'raw_event': raw_event
                    }
                }
                vulnerabilities.append(vulnerability)
            
            # Check for unusual API usage patterns
            api_calls = raw_event.get('eventName', '')
            if api_calls in ['AssumeRole', 'GetSessionToken', 'GetFederationToken']:
                # Check for unusual frequency
                if self._is_unusual_api_usage(event, events):
                    vulnerability = {
                        'type': 'runtime_vulnerability',
                        'title': 'Unusual API Usage Pattern',
                        'description': f'Unusual usage pattern detected for {api_calls}',
                        'severity': 'MEDIUM',
                        'cvss_score': 5.0,
                        'remediation': 'Review API usage patterns and implement rate limiting',
                        'affected_resource': event.get('resource_id', 'UNKNOWN'),
                        'source': event.get('source', 'UNKNOWN'),
                        'timestamp': datetime.utcnow().isoformat(),
                        'details': {
                            'api_call': api_calls,
                            'event_id': event.get('resource_id', ''),
                            'raw_event': raw_event
                        }
                    }
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _is_unusual_api_usage(self, event: Dict, all_events: List[Dict]) -> bool:
        """Check if API usage is unusual"""
        api_call = event.get('raw_event', {}).get('eventName', '')
        user = event.get('raw_event', {}).get('userIdentity', {}).get('userName', '')
        
        # Count similar API calls from the same user in the last hour
        recent_events = [
            e for e in all_events
            if e.get('raw_event', {}).get('eventName') == api_call
            and e.get('raw_event', {}).get('userIdentity', {}).get('userName') == user
        ]
        
        # Consider unusual if more than 10 calls in a short period
        return len(recent_events) > 10
    
    def _generate_summary(self, scan_results: Dict) -> Dict:
        """Generate vulnerability scan summary"""
        total_vulns = scan_results['total_vulnerabilities']
        
        if total_vulns == 0:
            status = 'SECURE'
            risk_level = 'LOW'
        elif scan_results['critical_vulnerabilities'] > 0:
            status = 'CRITICAL'
            risk_level = 'CRITICAL'
        elif scan_results['high_vulnerabilities'] > 2:
            status = 'HIGH_RISK'
            risk_level = 'HIGH'
        elif scan_results['medium_vulnerabilities'] > 5:
            status = 'MEDIUM_RISK'
            risk_level = 'MEDIUM'
        else:
            status = 'LOW_RISK'
            risk_level = 'LOW'
        
        # Calculate average CVSS score
        if total_vulns > 0:
            total_cvss = sum(vuln.get('cvss_score', 0) for vuln in scan_results['vulnerabilities'])
            avg_cvss = total_cvss / total_vulns
        else:
            avg_cvss = 0
        
        # Find most common vulnerability type
        vuln_types = [vuln.get('type', 'unknown') for vuln in scan_results['vulnerabilities']]
        most_common_type = max(set(vuln_types), key=vuln_types.count) if vuln_types else None
        
        return {
            'status': status,
            'risk_level': risk_level,
            'total_vulnerabilities': total_vulns,
            'average_cvss_score': round(avg_cvss, 1),
            'most_common_type': most_common_type,
            'critical_count': scan_results['critical_vulnerabilities'],
            'high_count': scan_results['high_vulnerabilities'],
            'medium_count': scan_results['medium_vulnerabilities'],
            'low_count': scan_results['low_vulnerabilities']
        }
    
    def _generate_recommendations(self, scan_results: Dict) -> List[str]:
        """Generate prioritized recommendations"""
        recommendations = []
        
        # Collect all remediation steps
        for vuln in scan_results['vulnerabilities']:
            remediation = vuln.get('remediation', '')
            if remediation and remediation not in recommendations:
                recommendations.append(remediation)
        
        # Prioritize by severity
        critical_recommendations = []
        high_recommendations = []
        medium_recommendations = []
        low_recommendations = []
        
        for vuln in scan_results['vulnerabilities']:
            severity = vuln.get('severity', 'LOW')
            remediation = vuln.get('remediation', '')
            
            if severity == 'CRITICAL' and remediation not in critical_recommendations:
                critical_recommendations.append(remediation)
            elif severity == 'HIGH' and remediation not in high_recommendations:
                high_recommendations.append(remediation)
            elif severity == 'MEDIUM' and remediation not in medium_recommendations:
                medium_recommendations.append(remediation)
            elif severity == 'LOW' and remediation not in low_recommendations:
                low_recommendations.append(remediation)
        
        # Combine and return top recommendations
        all_recommendations = critical_recommendations + high_recommendations + medium_recommendations + low_recommendations
        return all_recommendations[:10]  # Top 10 recommendations
    
    def save_scan_results(self, results: Dict, filepath: str):
        """Save scan results to file"""
        try:
            with open(filepath, 'w') as f:
                json.dump(results, f, indent=2, default=str)
            logger.info(f"Vulnerability scan results saved to {filepath}")
        except Exception as e:
            logger.error(f"Failed to save scan results: {e}")


def main():
    """Test the vulnerability scanner"""
    # Sample events for testing
    sample_events = [
        {
            'timestamp': datetime.utcnow().isoformat(),
            'source': 'AWS_EC2',
            'event_type': 'INSTANCE_LAUNCH',
            'resource_id': 'i-1234567890abcdef0',
            'description': 'EC2 instance launched with Log4j 2.15.0',
            'raw_event': {
                'eventName': 'RunInstances',
                'userIdentity': {'userName': 'testuser'},
                'software': 'log4j-2.15.0.jar'
            }
        },
        {
            'timestamp': datetime.utcnow().isoformat(),
            'source': 'AWS_S3',
            'event_type': 'BUCKET_ACCESS',
            'resource_id': 'my-bucket',
            'description': 'S3 bucket accessed with admin:admin credentials',
            'raw_event': {
                'eventName': 'GetObject',
                'userIdentity': {'userName': 'admin'},
                'credentials': 'admin:admin'
            }
        }
    ]
    
    # Sample resource configurations
    sample_configs = {
        's3_buckets': {
            'my-bucket': {
                'public_read': True,
                'encryption_enabled': False
            }
        },
        'ec2_instances': {
            'i-1234567890abcdef0': {
                'public_ip': True,
                'volumes': [
                    {'id': 'vol-1234567890abcdef0', 'encrypted': False}
                ]
            }
        }
    }
    
    scanner = VulnerabilityScanner()
    results = scanner.scan_vulnerabilities(sample_events, sample_configs)
    
    print(f"Vulnerability Scan Results:")
    print(f"Status: {results['summary']['status']} (Risk Level: {results['summary']['risk_level']})")
    print(f"Total Vulnerabilities: {results['total_vulnerabilities']}")
    print(f"Critical: {results['critical_vulnerabilities']}, High: {results['high_vulnerabilities']}, Medium: {results['medium_vulnerabilities']}, Low: {results['low_vulnerabilities']}")
    print(f"Average CVSS Score: {results['summary']['average_cvss_score']}")
    
    print("\nTop Recommendations:")
    for i, rec in enumerate(results['recommendations'][:5], 1):
        print(f"{i}. {rec}")


if __name__ == "__main__":
    main()
